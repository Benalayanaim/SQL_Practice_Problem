


/****************************************************************************************************************************/

/****************************************************************************************************************************/

#Problem 1
#https://github.com/mrinal1704/SQL-Leetcode-Challenge/blob/master/Medium/Exchange%20Seats.sql
#https://leetcode.com/problems/exchange-seats/

/**solution 1**/ 
SELECT
    CASE
        WHEN id = (SELECT(MAX(id)) FROM seat) AND id % 2 = 1 THEN id
        WHEN id % 2 = 1 THEN id + 1
        ELSE id - 1
    END AS id, student
FROM seat
ORDER BY id


-- Solution 2: 
with seats_cte as (
    select
        id,
        student,
        lag(student, 1) over (order by id) as prev_student,
        lead(student, 1) over (order by id) as next_student
    from Seat
)
select 
    id,
    case 
    when id % 2 = 0 and prev_student is not null then prev_student
    when id % 2 = 1 and next_student is not null then next_student
    else student end as student
from seats_cte


"Resource Foe Lag and Lead :"
--https://www.geeksforgeeks.org/postgresql-lag-function/?ref=ml_lbp
--https://www.geeksforgeeks.org/postgresql-lead-function/?ref=ml_lbp


/****************************************************************************************************************************/

/****************************************************************************************************************************/

#Problem 2
#https://github.com/mrinal1704/SQL-Leetcode-Challenge/blob/master/Medium/Find%20the%20start%20and%20end%20number%20of%20continuous%20ranges.sql
#https://leetcode.ca/2019-06-07-1285-Find-the-Start-and-End-Number-of-Continuous-Ranges/

/*Solution 1*/

WITH numbered_logs AS (
    SELECT 
        log_id,
        log_id - ROW_NUMBER() OVER (ORDER BY log_id) AS grp
    FROM Logs
),
ranges AS (
    SELECT 
        MIN(log_id) AS start_id,
        MAX(log_id) AS end_id
    FROM numbered_logs
    GROUP BY grp
)
SELECT 
    start_id,
    end_id
FROM ranges
ORDER BY start_id;



/*Solution 2*/

select min(log_id) as start_id, max(log_id) as end_id
from(
select log_id, log_id-row_number() over (order by log_id) as rk
from logs) a
group by rk



/****************************************************************************************************************************/

/****************************************************************************************************************************/

#Problem 3
#https://leetcode.com/problems/friend-requests-ii-who-has-the-most-friends/
#https://github.com/mrinal1704/SQL-Leetcode-Challenge/blob/master/Medium/Friend%20Requests%202.sql


/*Solution 1*/
WITH Friends AS (
    SELECT requester_id AS id, accepter_id AS friend_id
    FROM RequestAccepted
    UNION ALL
    SELECT accepter_id AS id, requester_id AS friend_id
    FROM RequestAccepted
),
FriendCounts AS (
    SELECT 
        id, 
        COUNT(DISTINCT friend_id) AS num
    FROM Friends
    GROUP BY id
)
SELECT 
    id, 
    num
FROM FriendCounts
WHERE num = (SELECT MAX(num) FROM FriendCounts);



/*Solution 2*/

with cte as (
    select requester_id as id from requestaccepted
    union all
    select accepter_id as id from requestaccepted
)
select id, count(id) as num 
from cte
group by id
order by num desc limit 1



/*Solution 3*/
WITH CTE AS(
SELECT requester_id , accepter_id
FROM RequestAccepted
UNION ALL
SELECT accepter_id , requester_id
FROM RequestAccepted
)
SELECT requester_id id, count(accepter_id) num
FROM CTE
group by 1
ORDER BY 2 DESC
LIMIT 1




"Resource Union All "

--https://www.geeksforgeeks.org/sql-union-all/
